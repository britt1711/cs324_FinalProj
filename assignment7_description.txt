****
**** EXPLANATION OF INTENDED GAME
****


Our game will be a slight spin on the retro arcade game “Defender”. The player’s character will be denoted by a colored circle that will be allowed to move around the screen based on the player’s mouse position. From the top of the screen, good and bad objects will begin to drop down. The player must navigate the screen, capturing good objects to gain points and avoiding bad objects, which will cause the player to lose lives. Once the player loses 5 lives, the game is over. As the game progresses in time played, the good and bad objects on the screen will drop at faster rates. The goal of the game is to stay alive and capture as many good objects as possible.

Our at least 3 rules of play include:
- Heroes and enemies are ellipses, differentiated by radius from a limited range of possible radiuses
- Heroes and enemies fall at a given rate from the top of the screen
- Player loses life for intersecting with an enemy object
- Player gains points for intersecting with hero objects
- For each new level, heroes and enemies fall at faster rates from top of screen
- After a certain time has elapsed, player moves on to the next level


Our at least 4 keyboard and/or mouse inputs include:
- Up arrow moves player object up the screen
- Down arrow moves the player object down the screen
- Left arrow moves the player object towards the left of the screen
- Right arrow moves the player object towards the right of the screen


The Win/lose conditions for our game are:
- Arbitrarily, we set winning the game as passing the 10th level
- Player loses once all lives are lost before the 10th level
- Goal is to have the highest possible points by the end of the game


****
**** EXPLANATION OF CLASSES
****


* Button Class *


This class defines the basic functionality of a button, including noting when the button has been selected or is being hovered over.


* ButtonRect Class *


This class extends the Button class to form a button of a rectangle shape.


* Timer Class *


This class defines Timer objects in order to have different objects run on different "clocks" without having to update the frameRate(). The class can return the elapsed time in number of seconds, which is heavily used throughout the program.


* Player Class *


This class defines Player objects, which is the user's character in the game. The player has a variable to track its lives left, points gained, and position on the screen.


* Enemy Class *


This class defines enemy (or bad) objects, which are objects that, when the player runs into them, results in a lost life for the player.


* Hero Class *


This class defines hero (or good) objects, which are objects that, when the player runs into them, results in gained points.


* __ Class *


This class defines ...


* __ Class *


This class defines ...


* __ Class *


This class defines ...














****
**** UNEXPECTED CHALLENGES
****


For Brittany:


Thinking about what page to move to next and when to call resets on different variables/objects made is so that I had to replay the program and go through my code very slowly. Initially figuring out how to allow the text at the bottom of the screen to blink was challenging. Additionally, setting the "time remaining until next level" for each level took me a while to do because I was not properly allowing the timer to pause.


For Ally:





For Dave:




****
**** OTHER INTERESTING FEATURES/EXTRA CREDIT
****


As part of Brittany's work, our program is very intuitive for the user to understand right after running the program. All applicable keyboard or mouse calls are noted on each page as the user moves through the program. Taking the concept of from our "Hands-On" relating to novelVisualization, she has included a background for the game that is written between margins of the screen, to further entice the player. There is also an instructions page on how to play. Timers have been utilized all throughout the game in order to have the game be more appealing (such as the blinking text at the bottom of some pages) as well as the countdown before each new level and the countdown within each level itself. 








****
**** MEMBER RESPONSIBILITIES
****


For this project, we split our overall simulation into four core parts. The first relates to the basic visual objects (which include Enemy class, Hero class, and Player class) and classes from our Hands-On assignments (including Button class and Timer class). The second relates to the organization of the main program in the group_11_assignment7.pde, such as what order to run each page the user sees and where to place menu options and player statistics throughout the game. The third relates to the Level class, which defines how our basic visual objects move on each level and how the user interacts with these objects. The fourth relates to the Game class, which describes how the game comes together as a whole, including how the user moves between levels and scores or loses lives.

Brittany worked on all classes relating to the first two core parts, including Enemy class, Hero class, Player class, Button and ButtonRect classes, and Timer class. She additionally worked on most of the logic in the functions seen under group_11_assignment7.pde.

Ally worked on all classes relating to the Level class, including the methods associated with calling variables from this class in the main group_11_assignment7.pde file. In order to help Dave integrate Level objects into the Games class, communication was needed between the two.

Dave worked on all classes relating to the Game class, including the methods associated with calling variables from this class in the main group_11_assignment7.pde file. In order to integrate Level and Player objects into the Games class, communication was needed between the him and the rest of the team.
